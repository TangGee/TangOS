ARM_CROSSPREFIX ?= aarch64-linux-android-

board ?= rpi4

ifeq ($(board), rpi3)
CFLAGS += -DCONFIG_BOARD_PI3B
QEMU_OPS  += -machine raspi3
else ifeq ($(board), rpi4)
CFLAGS += -DCONFIG_BOARD_PI4B
QEMU_OPS  += -machine raspi4
endif

CFLAGS += -g -Wall -nostdlib -nostdinc -Iinclude
ASM_FLAGS = -g -Iinclude

BUILD_DIR = build
SRC_DIR = src


#注意每行后面不要有空格，否则会算到目录名里面，导致问题
SRC_DIR = src
BUILD_DIR = tmp
OBJ_DIR = $(BUILD_DIR)/obj
DEPS_DIR  = $(BUILD_DIR)/deps
 
#这里添加其他头文件路径
INC_DIR = \
	-I./include \
	-I./src \
	
#这里添加编译参数
CC_FLAGS := $(INC_DIR) -g -std=c++11
LNK_FLAGS := \
	-L/usr/local/lib 
 
#这里递归遍历3级子目录
DIRS := $(shell find $(SRC_DIR) -maxdepth 3 -type d)
 
#将每个子目录添加到搜索路径
VPATH = $(DIRS)
 
#查找src_dir下面包含子目录的所有cpp文件
SOURCES   = $(foreach dir, $(DIRS), $(wildcard $(dir)/*.cpp))  
OBJS   = $(addprefix $(OBJ_DIR)/,$(patsubst %.cpp,%.o,$(notdir $(SOURCES))))  
DEPS  = $(addprefix $(DEPS_DIR)/, $(patsubst %.cpp,%.d,$(notdir $(SOURCES))))  
$(TARGET):$(OBJS)
	$(CC) $^ $(LNK_FLAGS) -o $@
#编译之前要创建OBJ目录，确保目录存在
$(OBJ_DIR)/%.o:%.cpp
	if [ ! -d $(OBJ_DIR) ]; then mkdir -p $(OBJ_DIR); fi;\
	$(CC) -c $(CC_FLAGS) -o $@ $<
#编译之前要创建DEPS目录，确保目录存在
#前面加@表示隐藏命令的执行打印
$(DEPS_DIR)/%.d:%.cpp
	@if [ ! -d $(DEPS_DIR) ]; then mkdir -p $(DEPS_DIR); fi;\
	set -e; rm -f $@;\
	$(CC) -MM $(CC_FLAGS) $< > $@.$$$$;\
	sed 's,\($*\)\.o[ :]*,$(OBJ_DIR)/\1.o $@ : ,g' < $@.$$$$ > $@;\
	rm -f $@.$$$$
#前面加-表示忽略错误
-include $(DEPS)
.PHONY : clean
clean:
	rm -rf $(BUILD_DIR) $(TARGET)


all : tang.bin

clean :
	rm -rf $(BUILD_DIR) *.bin

$(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c
	mkdir -p $(@D)
	$(ARM_CROSSPREFIX)gcc $(CFLAGS) -MMD -c $< -o $@

$(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S
	$(ARM_CROSSPREFIX)gcc $(ASM_FLAGS) -MMD -c $< -o $@

C_FILES = $(wildcard $(SRC_DIR)/*.c)
ASM_FILES = $(wildcard $(SRC_DIR)/*.S)
OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o)
OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o)

DEP_FILES = $(OBJ_FILES:%.o=%.d)
-include $(DEP_FILES)

tang.bin: $(SRC_DIR)/tang.link.lds $(OBJ_FILES)
	$(ARM_CROSSPREFIX)ld -T $(SRC_DIR)/tang.link.lds -Map tang.map -o $(BUILD_DIR)/tang.elf  $(OBJ_FILES)
	$(ARM_CROSSPREFIX)objcopy $(BUILD_DIR)/tang.elf -O binary tang.bin

QEMU_FLAGS  += -nographic

run:
	qemu-system-aarch64 $(QEMU_FLAGS) -kernel tang.bin
debug:
	qemu-system-aarch64 $(QEMU_FLAGS) -kernel tang.bin -S -s


PHONY += help
help :
	@echo  "make all, build tang os"
	@echo  "make run, build tang os, and run qemu"
	@echo  "make debug, build tang os, and run qemu and debug"